---
title: "Midday Stack Overview"
"og:title": "Midday.ai – Full-Stack Architecture in Plain English"
description: "How the Midday stack fits together, why we picked each piece, and what you can safely leave out."
icon: layers
---

## 1 · 30-second pitch
> Browser, API and database all share the **same TypeScript types**.  
> Supabase gives us Postgres + Auth + Storage.  
> A tiny **Hono** server mounts **tRPC** for the dashboard and an **optional** REST layer for 3rd-parties.  
> A Cloudflare Worker called **Engine** talks to banks & AI so the core API never touches vendor SDKs.

## 2 · Layers

| Layer | What lives here | Key tech |
|-------|-----------------|----------|
| UI | Next.js + React Query + tRPC hooks | typed queries, cache |
| Core API | Hono (`apps/api`) | auth, business rules, DB routing |
| Database | Supabase Postgres (primary + replicas) | RLS, JWT |
| Edge Integrations | Cloudflare Worker (`apps/engine`) | bank SDKs, Workers AI |

## 3 · Request flows

* Dashboard read → **tRPC** → API → replica DB  
* Dashboard write → **tRPC** → API → primary DB  
* File upload / realtime → browser **direct ↔ Supabase**  
* Bank sync → API ↔ **Engine** ↔ Plaid / Teller

## 4 · React Query ❤ tRPC

1. **Autogenerated hooks** – `trpc.foo.get.queryOptions()` builds a fully-typed React Query config.  
2. **Single-source cache** – React Query is the one truth; tRPC helpers invalidate automatically.  
3. **Transport batching** – tRPC batches calls, React Query handles dedupe & retries.  
4. **Optimistic updates** – built-in rollback.  
5. **SSR & hydration** – prefetch on the server, dehydrate, hydrate—no extra code.  
6. **Background refetch** – React Query keeps data fresh while user browses.

## 5 · Two ways to hit Postgres

| Path | When to use it | Example |
|------|----------------|---------|
| Supabase client (browser) | auth, realtime, simple RLS-safe reads | `supabase.from('profiles').select()` |
| Drizzle ORM (server) | joins, cross-team checks, primary/replica routing | `db.select().from(transactions)…` |

## 6 · What’s optional?

| Component | Keep for MVP? | Add when… |
|-----------|---------------|-----------|
| REST layer | ❌ | you expose public API/webhooks |
| Engine Worker | ❌ | you need vendor integrations or edge AI |
| Multi-region replicas | ❌ | you hit >1k rps or global latency |
| Supabase Storage / Realtime | 🔄 | only if you need uploads/live updates |
| tRPC + React Query | ✅ | core of the type-safe DX |

## 7 · “Lean Starter” recipe

1. Supabase project  
2. Next.js dashboard  
3. `@trpc/server` + `@trpc/react-query`  
4. Hono server exposing only `/trpc/*`  
5. Drizzle ORM

## 8 · Explaining it to a teammate

> “Frontend already **knows** backend types. Most reads/writes flow through tRPC. Simple auth/uploads talk straight to Supabase. Anything vendor-specific lives in one Worker so outages don’t break the API. Drop REST or the Worker if you don’t need them.”

## 9 · If we rebuilt tomorrow

Keep: Supabase, Hono, tRPC, Drizzle, React Query  
Add later: REST, Engine, replicas  
Maybe swap: Supabase Edge Functions instead of a custom Worker if integrations stay simple.

## 10 · Shared packages in `packages/`

| Package | What it is | Why it’s a separate library |
|---------|------------|-----------------------------|
| **`jobs`** | All Trigger.dev/cron jobs (`src/tasks/**`) | Avoid pulling heavy Trigger.dev deps into every app; jobs are runnable in workers or CI. |
| **`invoice`** | Invoice editor, PDF/HTML/OG templates, token helpers | Same rendering code is reused by Dashboard, API (PDF), and Jobs; React-free template rendering. |
| **`inbox`** | “Magic Inbox” utilities: email/webhook parsers, attachment helpers | Used by API webhook endpoints *and* Jobs that match documents—shared to prevent circular deps. |
| **`location`** | Static country, currency & timezone data + lookup helpers | 300 KB of JSON kept out of main bundles; tree-shake or omit if an app doesn’t need geo lookups. |

**Rule of thumb**:  
*`apps/*` are runnable programs.  
*`packages/*` are Lego bricks they all share.*

Now you—and anyone cloning the repo—know *exactly* what each piece does and when it’s safe to skip it.